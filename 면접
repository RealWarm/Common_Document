지원동기 >> 내가 이 회사에서 어떤사업을 하고싶다 밝히는것
1. 사회경제 문화의 변화 이야기
2. 지원한 기업이 하고있는 사업의 비전
3. 비전을 실현시킬 나의 역량 어필
=========================================================================
자소서에 쓴 경험을 정리해서 역량에 어떻게 기여할건지
여행많이 다녔다 >> 뭘 느꼈니? >> 자유로웠다. >> 걍 놀러다녔구나
마인드맵써보면 좋다
=========================================================================
1분 자기소개
나는 생각보다 대단한 사람이다 >> 기죽지 말자.
1. 비유하지 말자 >> 남들도 똑같다.
2. 튀려고 하지말자.

담담하게 역량을 어필하자 >> 꼬리질문 >> 매력

저는 어떤 역량을 가지고 있는 사람입니다.
이 역량(경험)은 이런 활동을 통해서 얻게 되었습니다.
그리고 저는 이런역량을 토대로
이 회사의 어떤 사업에 기여하고 싶습니다.
역량 = 지식 + 기술 + 태도

역량 + 가치관도 좋다.
=========================================================================
## 인성면접
라인플러스 면접 예상 질문리스트(+질문의도)

1. 당신에 대한 소개와 자신의 장단점은 무엇입니까?
(자신의 이야기를 통해 객관적인 시각을 가지고 있는지를 파악하기 위한 질문입니다.)

2. 남들이 자신을 어떤 사람으로 보고 있다고 생각하십니까?
(자기분석이 아닌 타인 분석을 묻는 질문입니다.)

3. 지금까지 가장 기뻤던 일은 무엇입니까?
(사건뿐 아니라 그것을 통해 어떤 가치관을 얻었는가 를 묻는 질문입니다.)

4. 대학생활 중, 학업 외에 어떤 일에 몰두했습니까?
(학창시절은 어떻게 보냈는지, 또 그것을 통해서 무엇을 얻었는지를 묻는 질문)

5. 학창시절에 어떤 아르바이트를 해 보았습니까?
(자기분석과 적성을 파악하기 위한 질문)

6. 이것만큼은 남에게 질 수 없다고 생각하는 것은?
(자신에 대한 장점을 묻고 있습니다. 성실성, 체력, 근성 등)

7. 좌절한 적이 있습니까?
(각각의 감정의 기질을 묻는 질문입니다.)

8. 대학시절 자신의 성적을 어떻게 생각하십니까?
(대학생활을 통해서 성실함의 정도를 묻는 질문)

9. 최근 뉴스에서 가장 관심을 가졌던 화제는?
(신문을 자주 읽고 있는지와 정보에 어느 정도 민감한지, 그리고 각각의 사고성을 묻는 질문입니다.)

10. 1억원이 있다면 무엇을 하시겠습니까?
(인생관이 독립지향인지 안전지향인지를 파악하기위한 질문입니다.)

11. 취미나 특기가 있습니까?
(면접자의 특별한 일면을 발견하기 위한 질문입니다.)

12. 휴일에는 주로 무엇을 합니까?
(외향적과 내향적으로 나눌 수 있는 성격과 우호관계를 묻는 질문입니다.)

13. 자신을 ‘사물’에 비유한다면 무엇이라고 생각합니까?
(잠재적인 성격과 감성을 연상하는 질문입니다.)

14. 회사에 들어오면 어떤 일을 하고 싶습니까?
(희망직종과 그 이유를 통해 개인의 비전을 알아보기 위한 질문입니다.)

15. 일에 대한 당신의 사고방식은?
(일에 대한 진취적인 자세와 정열을 가늠해보기 위한 질문입니다.)

16. 일과 사생활에 대하여 어떻게 생각하는가?
(회사에 대한 충성심을 파악하기 위한 질문입니다.)

17. 사회인과 학생의 차이는 무엇이라고 생각합니까?
(사회인으로서의 각오를 묻는 질문입니다.)

18. 이 회사가 부도 위기에 처한다면?
(귀속의식이나 일에 대한 사고방식을 묻는 질문입니다.)

19. 10년 후의 자신의 대하여 이야기 한다면?
(장래성과 관심사를 묻는 질문입니다.)

20. 그러면 이것으로 면접을 마치겠습니다. 질문 있습니까?
(물어볼 것이 있나?’의 본래 의도는 ‘우리 회사에 대해서 가장 관심이 있는 것은 무엇인가?’ 라는 의미 입니다.)
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////////////////////////////////////////////
==========================================================================
## 기술면접

정렬(Sorting)


++ Sorting Algorithm이 가짓수가 많은데 그 이유가 무엇일 것 같나요

- sorting algorithm마다 expected되는 속도가 다르다.

- 속도가 아닌 Space Comlexity가 고려대상이 될 수 있다. Merge sort같은 경우 insertion sort나 selection sort에 비해 추가 메모리 공간을 사용하기 때문

- Stable한지 안한지에 따라 사용되어야 할 sorting algorithm이 다를 수 있다.

++ Quick sort에 대해서 설명해 줄 수 있나요
Quick sort는 Divide-and-Conquer paradigm을 이용한다 그중에서도 Partitioning이라는 아이디어를 이용한다.

Partitioning이란 Pivot element를 기준으로 왼쪽은 Pivot보다 작거나 같은 것을 모아주고 오른쪽은 Pivot보다 크거나 같은것을 모아주는 것을 말한다.

Partitioning을 재귀적으로 진행하다보면 정렬이 완료된다.


++++++++++++++++++++++++++++자료구조+++++++++++++++++++++++++++++

@@ 빅오

- 빅오 표기법은 알고리즘의 효율성을 표기해주는 표기법이다(=최악의 경우) 
- 빅-오(Big-O), 빅-오메가(big-Ω),빅-세타(big-Θ) 표기법이 있다.
- 빅오메가는 하한선을 기준으로하고, 빅세타는 상한선과 하한선의 사이를 기준으로 표기한다.
- 빅 오메가 :: 빅 오와는 반대되는 개념입니다. 대개 최선의 경우라고 합니다.
- 빅 세타  :: 빅 세타는 빅 오와 빅 오메가의 공통부분입니다. 최소와 최악의 중간인 평균적인 복잡도이죠.


@@ Array(배열)
- 인덱스로 해당원소에 접근할 수 있다. >> 인덱스를 안다면 O(1)만에 접근할 수 있다(= random access가 가능하다)

- 삽입과 삭제는 O(1)이지만, 빈 부분을 채우기 위해서 O(n)만큼의 시간이 걸린다.

@@ Linked List
- 논리적 저장 순서와 물리적 저장 순서가 일치하지 않는다.
- 자기 자신 다음에 어떤 원소인지만 기억하고 있다. >> search에 O(n)이 걸림
- 배열의 삽입, 삭제는 O(1)가 아니라 O(n)걸림 >> serch 때문에

@@ Stack
- 선형 자료구조의 일종으로 LIFO. 즉 나중에 들어간 원소가 먼저 나온다.

@@ Queue
- 선형 자료구조의 일종으로 FIFO. 즉 먼저 들어간 원소가 먼저 나온다.

@@ Tree
- 비선형 구조다. 계층적 관계를 표현하는 자료구조이다.
- 사이클이 없는 그래프
- 구성요소
	* 간선
	* 노드	
		* 루트노드 : 최상위 노드
		* 단말노드 : 최하위의 다른 노드가 연결되어있지 않은 노드
		* 내부노드 : 단말노드를 제외한 모든 노드로, 루트노드를 포함한다.
	* 레벨 : 해당 노드의 높이
- 이진트리
	* 서브트리의 갯수가 2개인 트리
- 포화이진트리 : 모든 레벨이 꽉찬 이진트리
- 완전 이진트리: 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 채워진 이진트리

- 이진 탐색트리
	* 탐색 연산은 O(log n)의 시간 복잡도를 갖는다. 사실 정확히 말하면 O(h)라고 표현하는 것이 맞다

@@ Graph
- 방향이 있니 없니?
- 차수(Degree) :정점에 연결된 간선의 갯수
- 가중치가 모두 같니? & 모두 다르니?
- 인접행렬 	:: 2차원배열
- 인접리스트	:: 연결 리스트를 사용하는 방법

@@ Hash

++++++++++++++++++++++++++++운영체제+++++++++++++++++++++++++++++

++ 프로세스와 쓰레드의 차이를 설명해보세요

프로세스
- 프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것을 말한다.
- 프로세스는 실행되는 프로그램 자체와 프로그램이 실행되는 주변 환경을 포함하는 개념이다. 실행되는 주변 환경이란 사용중인 파일, 데이터, 메모리 영역 주소 공간등을 뜻한다.

쓰레드
- 스레드는 프로세스의 실행 단위라고 할 수 있다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다. 

++ 크롬 탭이 프로세스인지 쓰레드인가요

크롬은 탭마다 PID를 가지고 있으니 Process이며 각 Tab마다 랜더링 정보나 기타 데이터를 따로 관리한다고 한다. 그로인해 메모리를 많이 잡아먹기도 하지만 하나의 Tab에 오류가 생겼다고 모든 Tab에 영향을 끼치진 않는다.

@@ 캐시의 지역성 원리
- 캐시 메모리는 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다. 이러한 역할을 수행하기 위해서는 CPU 가 어떤 데이터를 원할 것인가를 어느 정도 예측할 수 있어야 한다. 캐시의 성능은 작은 용량의 캐시 메모리에 CPU 가 이후에 참조할, 쓸모 있는 정보가 어느 정도 들어있느냐에 따라 좌우되기 때문이다.


+++++++++++++++++++++++++++++ 네트워크 +++++++++++++++++++++++++++++

@@ IPv4 IPv6의 차이점

@@ HTTTP와 HTTPS의 차이첨
- HTTPS는 SSL 의 껍질을 덮어쓴 HTTP 라고 할 수 있다. 즉, HTTPS 는 새로운 애플리케이션 계층의 프로토콜이 아니라는 것이다. HTTP 통신하는 소켓 부분을 
SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 프로토콜로 대체하는 것 뿐이다. HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP는 SSL 과 통신하고 SSL 이 TCP 와 통신 하게 된다. SSL 을 사용한 HTTPS 는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.

- 모든 웹 페이지에서 HTTPS 를 사용하지 않는 이유
평문 통신에 비해서 암호화 통신은 CPU 나 메모리 등 리소스가 많이 필요하다. 통신할 때마다 암호화를 하면 많은 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 줄어들게 된다. 그렇기 때문에 민감한 정보를 다룰 때만 HTTPS 에 의한 암호화 통신을 사용한다.

@@ GET
- 요청데이터가 헤더에 담겨 전송된다
- 서버의 값이나 상태를 바꾸지않고, 

@@ POST


@@ TCP(Transmission Control Protocol)
- 

@@ UDP(User Datagram Protocol)

@@ SSL(TLS) 동작방식

클라이언트가 서버에 접속하며 랜덤 데이터를 전송. (Client hello)
서버가 Client hello에 대한 응답으로 Server hello를 함 (이때 인증서와 랜덤데이터 제공)
클라이언트의 브라우저에서 서버가 건네준 인증서가 CA에서 발급된건지를 확인하고 공개키로 인증서를 복호화한다. (인증서가 믿을 수 있다고 판단함)
클라이언트와 서버의 각각의 랜덤 데이터를 가지고 클라이언트에서 pre master secret값을 만들어냄 (대칭키)
pre master secret 값을 비대칭키 (클라이언트가 알고있는 공개키)를 이용하여 암호화하고 이를 서버에 보냄 이렇게 암호화 된 값을 master secret이라하고 이는 session key를 만들어냄
이 session key를 이용하여 서버와 클라이언트는 대칭키 방식으로 암호화 통신을 함


@@ TCP란 무엇인가
데이터의 송수신을 위해 IP를 이용하는 프로토콜이며, 통신간에 신뢰성을 보장해주기 위해 만든 것이다.

TCP는 3-way handshake라고 불리는 연결 동작과 4-way handshake라고 불리는 연결 종료를 통해 ACK와 Sequence Number를 주고 받아 데이터 흐름의 신뢰성을 구축한다.

++ TCP와 UDP의 차이점은
TCP는 연결 동작을 통해 ACK와 Sequence Number를 주고받으며 신뢰성과 흐름제어를 제공하는 
반면 UDP는 IP를 거의 그대로 사용하며 단순히 Checksum말고는 데이터의 훼손을 감지할 수 없다. 
또한 ACK와 Sequence Number를 주고받지 않으므로 중간에 데이터가 유실되어도 이를 다시 요청하거나 할 수 있는 방법이 없다. 
또한 TCP와 다르게 UDP는 혼잡을 제어할 수 있는 방법이 없다.

++ 브라우저에서 주소창에 url 입력시 어떤일이 일어나는가
1. 브라우저의 주소창에 url 입력
2. 브라우저 캐시에서 DNS 레코드를 확인하여 IP주소를 찾음 
	(없다면 DNS resolver를 통해 IP주소를 알아냄)
3. 브라우저가 서버와 TCP 연결을 시작함
4. 브라우저가 웹 서버에 HTTP 요청을 보냄
5. 서버가 요청을 처리하고 응답을 되돌려보냄
6. 브라우저는 서버가 보낸 HTML 내용을 표시


+++++++++++++++++++++++++++++ 자바 ++++++++++++++++++++++++++++++++
https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html

++ Object Oriented Programming 란?

++ 자바 프로그램이 실행되는 과정

++ 오버로딩과 오버라이딩의 차이점

@@ 오버로딩
- 하나의 메소드 이름으로 여러 기능을 담기위해 만들어짐 >> 매개변수의 타입, 개수, 순서 중 하나가 달라야한다
- 클래스내에 같은 이름의 메소드를 여러개 선언하는 것
- 존재의 이유 :: 매개값을 다양하게 받아 처리할 수 있도록 하기위함
- 오버로딩 메소드를 호출할 경우 JVM은 매개값의 타입을 보고 메소드를 선택한다.
	>> 일차적으로 매개 변수 타입을 보지만, 매개변수의 타입이 일치하지 않을 경우, 자동 타입 변환이 가능한지를 검사한다.

쌤 :: 오버로딩(Overloading) 종류(2가지)

   가. 생성자 오버로딩
   나. 메소드 오버로딩

   오버로딩 이란 ?
   1) 생성자/메소드와 같은 이름을 가지는 메소드
   2) (중요*****) 대신, 생성자/메소드의 
       매개변수의 타입/개수/순서가 틀려야 함!!!


** 주의
- 매개변수의 타입과 개수, 순서가 똑같을 경우 매개변수 이름만 바꾸는 것은 오버로딩이 아니다
- 리턴 타입만 다르고 매개변수가 동일한 것은 오버로딩이 아니다. >> 자바 가상기계가 도움을 주지 못하기 때문

++ 인스턴스 멤버 >> 객체 생성후 사용가능한 필드와 메소드
- 인스턴스 필드는 객체마다 존재한다.
- 인스턴스 메소드는 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다.

++ 필드와 변수의 차이점

++ main이 public static void인 이유
- p.241 main 메소드도 정적 메소드 이므로 객체 생성 없이 인스턴스 필드와 메소드를 바로 사용할수 없다

++ 싱글톤
- 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야하는 경우 >> 단 하나만 생성된다고 해서 이 객체를 싱글톤이라고 한다.
- 생성자에 private를 붙여서 생성자 호출을 막는다.
- 자신의 타입인 정적필드(privatet static)를 하나 선언하고 자신의 객체를 생성해 초기화 한다 >> private 덕분에 외부에서 수정불가
- 외부에서 호출 할 수 있는 정적 메소드인 getInstance메소드를 호출하여 자신의 객체를 리턴해준다



@@ 어노테이션 P.272
- 메타데이터다 >> 앱이 처리할 데이터가 아니라, 컴파일 과정과 실행 과정에서 어떻게 컴파일하고 처리할지 알려주는 정보이다.
- 용도
1. @Target :: 적용대상을 정한다.
2. @Retention :: 어노테이션 유지정책

@@ 프로그램
- 어떤 작업을 위해 실행 할 수 있는 파일
- 실행 가능한 명령어의 집합

++ 프로세서
CPU를 말하며 컴퓨터 하드웨어에 부착한 모든 장치의 동작을 제어하고 명령을 실행한다.

++ 스레드의 정의

++ 프로세스의 정의
프로세스 는 실행 중인 프로그램이다. 디스크에서 메모리로 적재되어, CPU 자원의 할당을 받을 수 있는 것을 말한다. 프로세스 에 할당되는 메모리 안에는 스택, 힙, 데이터, 코드 영역을 포함한다.

++ 정적 멤버와 static
- 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드 >> 정적 필드, 정적 메소드라고 부른다.
- 정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클랙스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.
- 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 영역에 적재할때 클래스별로 관리한다. >> 클래스 로딩이 끝나면 바로 사용할 수 있다.
- 정적필드는 정적블록에서만 초기화 가능하다 >> 정적블록은 클래스가 메모리에 로딩될때 자동적으로 실행된다
- p.240 :: 정적 블록 내부에서 그 클래스의 인스턴스 필드와 메소드는 사용할수 없다. >> 정적메소드와 정적블록에서 인스턴스 멤버를 
  사용하고 싶다면 객체를 먼저 생성하고 참조변수로 접근 해야한다.



쌤 :: OOP 의 다형성에 대해서
    가. 상속관계에서만 가능하다
    나. 자식클래스가 부모클래스로부터 상속받은
        메소드를 재정의(overriding)하면,
        자식객체가 물려받은 메소드를 호출 시에,
        재정의된 자식객체의 메소드가 대신 
        호출된다 (다형성-2)
    다. 다형성-1
        부모타입의 변수(또는 필드)에는,
        부모타입을 상속하는 자식타입의 객체를
        대입할 수 있다

24. 추상클래스

- 의미: 실체들의 공통된 성질을 뽑아내서 만든 클래스
        예: 새, 곤충, 사람 --> 동물(추상클래스)
- 실체 클래스의 부모 클래스 역할
- 왜? 부모 클래스 역할을 수행하느냐?
	- 클래스 레벨
	  여러 자식 클래스에, 공통된 성질/기능
	  (필드/메소드)을 상속시키는 게 목적
	- 클래스 설계입장에서보면
	  바로 "규격"을 제공하는 역할
	  (여기서, 규격이란, 추상크래스를 부모로 삼는, 모든 자식 클래스는 강제적인 규격을 구현해야 함)
	- "규격"이 왜 필요한가?
        - 다형성!!!!!
        - 다형성은, 다형성-1/2에 의해서 구현
        - 이때, 추상 클래스가 제공하는 규격은
          모든 실체(자식) 클래스가 구현해야 할
          항목이 됩니다.
        - 이렇게 강제적인 규격이 제공되어야,
          다형성이 올바르게 구현될 수 있겠죠.


          
+++++++++++++++++++++++++++++ 스프링 ++++++++++++++++++++++++++++++++
25. 인터페이스 란?

    가. 한마디로, "객체사용설명서" 이다!!!!
    나. 두 객체가 상호작용할 때, 그 방식이
        상호간의 참조(주소)를 통해서, 직접
        메소드를 호출하는 경우 ---> 두 객체는
        Tightly Coupled 되었다 라고 표현!!
        <-> Loosely Coupled 관계로 풀어내야 함! (이 수단이, 바로 인터페이스!!!)

    다. 두 클래스 간에 상속관계에서는, 
        부모역할을 하는 클래스 --> 부모 클래스
        자식역할을 하는 클래스 --> 자식 클래스

        부모 클래스 == 상위클래스, 슈퍼클래스
        자식 클래스 == 하위클래스, 파생클래스

        부모클래스가 추상클래스인 경우(예: 동물)
        이 추상크래스를 상속받아, 추상메소드를
        구현하는(오버라이딩하는) 자식클래스를 특별히, "실체(concrete) 클래스" 라고 부른다!!!

    라. 인터페이스에서는, 인터페이스의 추상메소드를 구현하는 클래스 ---> 
        "구현(implementation) 클래스"

26. 익명객체 - 이름을 알 수 없는 객체
    두가지 종류가 있음
      (1) 익명구현객체 - 인터페이스에 대하여
      (2) 익명자식객체 - 부모클래스에 대하여       

27. 다형성을 가능하게 하는 조건
	(1) 부모/자식 또는 인터페이스/구현 관계
	(2) 자동형변환이 가능해야 함
	(3) 오버라이딩된 자식의 메소드는 호출가능

+++++++++++++++++++++++++++++++용어+++++++++++++++++++++++++++++++++++++

+++++++++++++++++++++++++++++데이터베이스++++++++++++++++++++++++++++++++
union
정규화

==============================예상질문===================================

==============================운영체제===================================
@@ 운영체제
- 모든 하드웨어와 모든 소프트웨어를 관리하는 컴퓨터 시스템의 한 부분

@@ CPU란?
- 제어장치 + 레지스터 + 버스 + 연산장치  
- 사용자로부터 입력 받은 명령어를 해석, 연산한 후 그 결과를 출력하는 역할

@@ 레지스터
- 극히 소량의 데이터나 처리중인 중간 결과를 일시적으로 기억해 두는 고속의 전용 영역을 레지스터라고 한다.

@@ 캐시
- 주기억 장치에 읽어들인 명령이나 프로그램들로 채워지는 버퍼 형태의 고속 기억 장치. 
- 주기억 장치와 CPU와의 사이에 설치되어 있는 고속 버퍼 메모리이다. 
- 캐시 메모리 또는 로컬 메모리라고도 한다.


@@ 프로세스와 스레드의 차이는 무엇인가요?
- 프로세스 : 실행중인 프로그램, 프로그램 실행의 인스턴스
- 스레드 : 프로세스의 작업 실행단위 >> 프로세스가 할당받은 자원을 이용하는 
  실행의 단위
- 프로세스에 할당되는 메모리 안에는 코드, 데이터, 힙, 스택 영역을 포함한다.
- 스레드는 프로세스 내에서 스택만 따로 할당받고, 코드 데이터 힙 영역은 공유한다.
- 스레드는 한 프로세스 내에서 동작하는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드 끼리 공유하면서 실행된다.

공통점
- PCB(프로세스 제어 블록)에 정보를 저장하듯, TCB(스레드 제어 블록)에 정보를 저장한다. 프로세스는 스레드를 한개 이상 가질수 있으므로 결국 PCB는 TCB의 리스트를 가르킨다.

@@ 컨텍스트 스위칭이란
- CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정
- 처리중인 프로세스가 대기를 하고, PCB에 프로세스의 상태를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업

@@ PCB(Process Control Block(프로세스 제어블록))란?
- 프로세스 생성시에 만들어지며, 주기억 장치에 유지된다.
- 프로세스에 대한 중요한 정보를 저장하고 있다
- 문맥전환 등 다른 프로세스를 처리해야 할 때, PCB에 현재 상태를 저장함으로써 나중에 그 작업 상태를 불러와 작업 재개가 가능해진다. 
- PID, 상태, 다음 명령어 주소 등의 정보가 저장됨.

@@ 교착 상태(=데드락)
-멀티 프로그래밍 환경에서 서로의 자원을 쓰고 싶은데, 서로가 쓰지를 못해서 발생한 무한 대기상태 입니다.

++ 발생조건 (상점비순)
상호배제 : 한 자원은 한 프로세스에 의해서만 사용됨
점유대기 : 프로세스는 자원을 가진채 다른 자원을 기다릴 수 있음
비선점	: 사용중인 자원을 다른 프로세스가 강제로 가져올 수 없음
순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 필요로하는 자원을 가지고있다

++ 해결방법
예방 : 4가지 조건 중 하나라도 만족되지 못하게 함
회피 : 알고리즘을 데드락이 발생하지 않도록 적용
회복 : 교착상태가 발생하면 그때 해결함
무시 : 회복과정의 성능저하가 더 심하다면 그냥 무시함

@@ 경쟁 상태 (Race Condition)
경쟁 상태란 두 개 이상의 프로세스 혹은 스레드가 공유 자원을 동시에 사용할 때 그 순서에 따라 결과가 달라지는 문제.
은행 잔고를 예제로 들면 은행 잔고라는 공유 데이터를 읽어와서 입금 연산과 출금 연산을 하는데, 동시에 접근해서 연산해버리면 한 쪽 연산이 반영이 안되는 문제

@@ 뮤텍스와 세마포어
- ﻿Mutex : 화장실에 들어갈 수 있는 키와 같은 역할을 한다. 사용할 때는 사용자가 가지고 있다가 다음 사용할 사람에게 전해준다. 즉, 사용하고 있는 사람이 가지고 있는 것이다. 뮤텍스 객체는 제어되는 섹션에 하나의 쓰레드만을 허용하기 때문에 해당 섹션에 접근하려는 다른 쓰레드들을 강제적으로 막음으로써 첫 번째 쓰레드가 해당 섹션을 빠져나올 때까지 기다리도록 합니다
-Semaphore : mutex와 비슷하지만 가장 큰 차이는 뮤텍스는 동기화 대상이 오직 하나 뿐이지만, 세마포어는 동기화 대상이 하나 이상일 때 사용한다.(뮤텍스는 상태가 0, 1 두개뿐이기 때문에 binary Semaphore라고도 한다.)

@@ 임계영역은 프로세스간 자원이 공유될 수 있는 코드 블록

@@ 크리티컬 섹션

@@ 프로세스 혹은 스레드의 동기화란 무엇인가?
공유되는 자원, 임계영역에 서로 다른 프로세스나 스레드가 접근할때 문제가 발생하지 않게 하기위해서 처리하는 과정(락, 세마포 등이 있다.)

@@ 동기, 비동기, 블로킹, 넌블로킹 차이
- 동기 : 어떤 일에 대한 요청과 응답(혹은 입출력)이 동시에 이루어져야 하는 것
- 비동기 : 어떤 일에 대한 요청과 응답이 동시에 이루어질 필요 없이 따로 이루어지는 것.
- 블로킹 : 어떤 요청에 대한 응답이 올 때까지 대기 하는 것. 즉 동기를 위해서는 블로킹 되어야 함
- 넌블로킹 : 어떤 요청에 대해서 응답을 대기하지 않고 계속 루틴을 수행하는 것. 
  비동기를 위해서는 넌블로킹 되어야 하지만, 넌블로킹이 비동기는 아니다(포함관계라고 생각하면 될 듯). 
  예를 들어 넌블로킹이면서, 요청에 대한 응답을 계속해서 요구하는 폴링 방식의 경우, 비동기라 보기는 힘들다. 
  이벤트 핸들러나 인터럽트를 통해 응답을 받는 것이 비동기 모델.

@@ CPU 스케줄링이란 무엇인가요?
- 메모리에 올라온 프로세스들 중 어떤 프로세스를 먼저 처리할지 일들의 순서를 정하는 일. 
- 스케줄링을 사용함으로써 다중 프로그래밍이 가능해지고 CPU이용률을 극대화 시킬 수 있다. 
  즉, 시스템의 자원을 효율적으로 사용하기 위해 한 프로세스가 CPU를 언제 얼마나 차지 할 것인가에 대한 순서 또는 방법을 결정짓는 방법이라고 할 수 있다.

@@ CPU 스케줄링 방법에는 대표적으로 어떤 것들이 있나요?

++ 비선점 스케줄링 
- 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링
- CPU를 할당받은 프로세스가 종료되거나, 입출력 조작을 위해 자발적으로 중지되기 전까지 CPU할당을 보장하는 스케줄링

1. FCFS (First Come First Served) : 먼저 온 녀석이 먼저 스케줄링을 받음. 중간에 반환하지 않는 비선점형이며, 시간이 긴 프로세스가 먼저 오면 효율성이 떨어짐

2. SJF (Short Job First) : 늦게 오더라도 수행시간이 짧은 프로세스에 먼저 할당. 이렇게 되면 수행시간이 긴 프로세스는 영원히 할당받지 못할 수도 있음(Starvation)

3. 비선점 우선순위
 - 각 프로세스에 우선순위를 부여하여 우선순위가 높은 순서대로 처리하는 기법
 - ﻿특징 : 우선순위가 같으면 FIFO 형식
 - 가장 낮은 우선순위를 부여 받은 프로세스는 무한 연기상태가 발생 할 수 도 있다.


++ 선점 스캐줄링

- 우선순위가 높은 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링(비선점 스케줄링의 경우 응답시간이 예상이 되는 장점이 있지만 중요한 일이 중요하지 않은 일을 기다리는 경우가 발생할 수 있다)

1. RR(Round Robin)
- 시간 할당량 동안만 실행한 후 완료되지 않으면 다음 프로세스에게 CPU를 양보하고 준비상태 큐의 가장 뒤로 배치

2. SRT(Shortest Remaining Time)
- 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 있는 프로세스의 실행시간을 비교하여 가장 짧은 실행시간을 요구하는 프로세스에게 CPU를 할당하는 기법

3. 선점 우선순위

- 준비상태 큐의 프로세스들 중에서 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법
- 특징 : 비선점 우선순위 기법을 선점형태로 변형한 것
- 준비상태 큐에 새로 들어온 프로세스의 우선순위가 현재 프로세스보다 높을 경우 CPU를 새로운 프로세스에게 할당함

@@ 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.
- 프로세스에 할당되는 메모리 안에는 코드, 데이터, 힙, 스택, 영역을 포함한다.

++ 코드영역
- 우리가 작성한 소스코드가 들어 가는 부분. 즉, 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code)영역이라고도 부른다.
- 코드영역은 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 함수, 제어문, 상수 등이 여기에 지정된다.

++ 데이터 영역
- 전역변수와 static변수가 할당되는 영역 프로그램의 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리가 소멸되는 영역

++ 스택 영역
- 프로그램이 자동으로 사용하는 임시 메모리 영역이다.
- 함수 호출 시 생성되는 지역 변수와 매개변수가 저장되는 영역이고, 함수 호출이 완료되면 사라집니다.

++ 힙 영역
- 프로그래머가 할당/해제하는 메모리 공간이다.
- Java에서는 가비지 컬렉터가 자동으로 해제합니다.
- 이 공간에 메모리 할당하는 것을 동적 할당(Dynamic Memory Allocation)이라고도 부른다.
- 예를 들어 클래스, 클로저가 이 부분에 해당 된다. 런타임 시에 크기가 결정된다.

** 위의 HEAP과 STACK영역은 사실 같은 공간을 공유한다. HEAP이 메모리 위쪽 주소부터 할당되면 STACK은 아래쪽부터 할당되는 식이다. 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 HEAP OVERFLOW, STACK OVERFLOW라고 칭합니다.

Stack 영역이 크면 클 수록 Heap 영역이 작아지고, Heap 영역이 크면 클수록 Stack 영역이 작아집니다.

@@ 단편화란?
- 단편화란 메모리 상에서 적재되고, 해제되는 과정에서 발생하는 메모리 사이의 사용하지 못할 정도로 작은 빈 공간이다.
- 외부 단편화 : 프로세스와 프로세스 사이에 발생하는 빈 공간
- 내부 단편화 : 프로세스 안에서 발생하는 빈 공간이다
* 외부 단편화는 메모리를 다시 재정렬하는 압축을 통해 해결할 수 있지만, 효율이 좋지 않다

- First Fit : 메모리를 할당할 때, 가장 먼저 발견한 곳에 집어넣음
- Best Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 작은 곳에 집어넣음(정렬 필요)
- Worst Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 큰 곳에 집어넣음(정렬 필요)
- 공간 효율성 : Best Fit > First Fit > Worst Fit
- 시간 효율성 : First Fit > Best Fit = Worst Fit
 
@@ 페이지 교체 알고리즘 종류
++ FIFO(First In First Out): 말 그대로 먼저 들어온 페이지를 먼저 내보낸다. 간단한 알고리즘이지만, 페이지의 중요도를 따지지 않기 때문에 초기 변수가 담긴 페이지를 내려버리는 등 여러 문제를 초래할 수 있다.

++ 최적 페이지 교체 (Optimal Page Replacement) : 앞으로 가장 사용되지 않을 페이지를 계산하여 교체한다. 다만 모든 프로세스의 계획을 파악하기가 쉽지 않기 때문에, 어떤 페이지를 교체해야 하는가의 알고리즘을 구현할 때 어려움이 있다.

++ LRU (Last Recently Used) : 가장 나중에 사용된 페이지를 교체한다. FIFO보단 낫고 OPT보단 못하다.

++ LFU (Least Frequently Used) : 가장 덜 사용된 페이지를 교체한다. 활발한 페이지는 사용이 많이 되었을거라는 가정하에 만든 알고리즘. 초기에 많이 사용되었다가 지금은 사용되지 않는 페이지의 경우 교체가 이루어지지 않는다는 문제가 있다.

++ MFU (Most Frequently Used) : 가장 많이 사용된 페이지를 교체한다. 가장 적게 사용된 페이지가 최근에 올라오고 계속 사용될 것이라는 가정. 잘 쓰이지 않는다.

==============================네트워크===================================
@@ 쿠키
- 웹 브라우저가 보관하는 데이터

@@ OSI 7LAYER(물데네 전세표응)
- 정의 : 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약
- 각층은 독립되어있다 >> 통신이 일어나는 과정을 단계별로 파악하여, 문제 발생시 트러블슈팅이 용이하다

@@ TCP/IP
- TCP : 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
- 통신에 실제 사용되는 계층
- 네트워크, 인터넷, 전송, 응용 계층
- 일반적으로 TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 *패킷을 추적 및 관리하게 됩니다. 
  TCP는 연결형 서비스를 지원하는 프로토콜로 인터넷 환경에서 기본으로 사용합니다.
- TCP 특징
  - 연결형 서비스로 가상 회선 방식을 제공한다.
  - 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
  - 흐름 제어 및 혼잡 제어.
  - 높은 신뢰성을 보장한다.
  - UDP보다 속도가 느리다.
  - 전이중(Full-Duplex), 점대점(Point to Point) 방식.

@@ DNS(Domain Name System)
- 도메인 이름을 네트워크 주소로 바꾸거나, 그 반대의 변환을 수행할 수 있는 시스템

@@ TCP와 UDP의 차이점은
TCP는 연결 동작을 통해 ACK와 Sequence Number를 주고받으며 신뢰성과 흐름제어를 제공하는 
반면 UDP는 IP를 거의 그대로 사용하며 단순히 Checksum말고는 데이터의 훼손을 감지할 수 없다. 
또한 ACK와 Sequence Number를 주고받지 않으므로 중간에 데이터가 유실되어도 이를 다시 요청하거나 할 수 있는 방법이 없다. 
또한 TCP와 다르게 UDP는 혼잡을 제어할 수 있는 방법이 없다.

@@ 브라우저에서 주소창에 url 입력시 어떤일이 일어나는가
1. 브라우저의 주소창에 url 입력
2. 브라우저 캐시에서 DNS 레코드를 확인하여 IP주소를 찾음 
  (없다면 DNS resolver를 통해 IP주소를 알아냄)
3. 브라우저가 서버와 TCP 연결을 시작함
4. 브라우저가 웹 서버에 HTTP 요청을 보냄
5. 서버가 요청을 처리하고 응답을 되돌려보냄
6. 브라우저는 서버가 보낸 HTML 내용을 표시

@@ HTTP와 HTTPS 의 차이는 무엇인가요?

 ++ HTTP(Hyper Text Transfer Protocol)
- 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜이다.
- 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로, 80번 포트를 사용하고 있다. 

++ HTTP(Hyper Text Transfer Protocol Secure)
- HTTP에 데이터 암호화가 추가된 프로토콜이다. HTTPS는 HTTP와 다르게 433번 포트를 사용하며, 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 공개키 암호화를 지원하고 있다.

@@ HTTP GET과 POST의 차이는 무엇인가요?
GET
- 서버로부터 정보를 조회하기 위해 설계된 메소드입니다.
- GET은 요청을 전송할 때 필요한 데이터를 Body에 담지 않고, 쿼리스트링을 통해 전송합니다. 
- URL의 끝에 ?와 함께 이름과 값으로 쌍을 이루는 요청 파라미터를 쿼리 스트링이라고 부릅니다. 

POST
- 리소스를 생성/변경하기 위해 설계되었다.
- 전송해야될 데이터를 HTTP 메세지의 Body에 담아서 전송합니다. 
- HTTP 메세지의 Body는 길이의 제한없이 데이터를 전송할 수 있습니다. 
  그래서 POST 요청은 GET과 달리 대용량 데이터를 전송할 수 있습니다. 

@@ 쿠키와 세션

@@ REST API란?
- REST는 HTTP기반으로 필요한 자원에 접근하는 방식을 정해놓은 아키텍쳐입니다.
- 자원(RESOURCE) - URI
- 행위(Verb) - HTTP METHOD
- 표현(Representations)

@@ RestFul 하다는 것은?
=========================================================================

=========================================================================

=========================================================================
서블릿
jdbc : java Data Base Connectivity
커넥션 풀 : 
- 풀에서 미리 생성된 커넥션을 가져온다
- 사용한다 >> 풀에 반환한다.

@@ 서블릿이란?
- 클라이언트의 요청을 처리하고, 그 결과를 반환하는 
  Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술
- MVC 패턴에서 Controller로 이용된다.
- 웹 기반의 요청에 대한 동적인 처리가 가능한 하나의 클래스

@@ 웹 서버
- 클라이언트가 요청한 정적인 콘텐츠를 (HTTP 프로토콜을 통하여) 제공해주는 서버입니다
- 동적인 요청이 클라이언트로부터 들어왔을 때, 해당 요청을 웹 서버에서 처리할 수 없기 때문에 컨테이너(Container)로 보내주는 역할

@@ 웹 컨테이너
- 컨테이너는 동적인 데이터들을 처리하여 정적인 페이지로 생성해주는 소프트웨어 모듈
- 사용자의 요청이 들어오면 웹 서버는 정적인 요소만 클라이언트 측에 보낼 수 있고, 동적으로 처리해야 하는 부분은 처리할 수 없습니다. 
  컨테이너는 이러한 부분을 대신 처리해서 웹 서버에 정적인 파일로 만들어서 보내주는 모듈이라고 생각하면 될 것 같습니다.

@@ WAS (Web Application Server)
- 웹 서버 + 웹 컨테이너
- J2EE 스펙을 구현한 서버
- 웹 서버로부터 오는 동적인 요청을 처리하는 서버를 말합니다.

@@ 모델1
- 웹 브라우저의 요청을 JSP가 직접 처리한다
- 받은 요청을 JSP가 자바빈이나 서비스 클래스를 사용해서 작업을 처리하고 
  그 결과를 클라이언트에 출력한다
- 비즈니스 로직을 처리하는 코드와 웹브라우저에 결과를 출력하는 코드가 섞여있다.

@@ MVC
- 웹 브라우저의 모든 요청을 서블릿에서 처리한다.
- 구성요소
  1. 모델(= 서비스) : 비즈니스 로직을 처리한다.
  2. 뷰 : 사용자가 보게될 화면을 처리한다.
  3. 컨트롤러(= 서블릿) : 사용자의 입력처리와 흐름제어를 담당한다.
- 비즈니스 로직을 처리하는 모델과 결과 화면을 보여주는 뷰를 분리한다.
- 어플리케이션의 흐름제어나 사용자의 처리요청은 컨트롤러에 집중된다.
- 유지보수가 쉬워지고 쉽게 확장할 수 있다.

@@ 필터 :: HTTP 요청과 응답을 변경할 수 있는 재사용 가능한 클래스
- 클라이언트의 요청과 최종자원 사이에 위치하여 요청 정보를 알맞게 변경할 수 있다.
===================================자바==================================
@@ 접근 제한자
적용대상 :: 클래스, 필드, 생성자, 메소드
클래스한테는 public, default만 적용된다
- public
- protected
  - 같은 패키지 내에서 + 다른 패키지 클래스가 자식클래스라면 사용가능
- default
  같은 패키지 내에서만 사용 할 수 있다.
  클래스가 public을 생략했다면 디폴트다!
- private
  - 같은 패키지이건 다른패키지이건 아에 접근불가
  - 오로지 클래스 내부에서만 접근가능

@@ JVM의 구조
- 클래스로더 : 컴파일된 자바 바이트 코드를 런타임 데이터 영역에 로드한다.
- 실행 엔진 : 클래스 로더를 통해 JVM내의 런타임 데이터 영역에 배치된 바이트 
  코드를 실행한다.
- 런타임 데이터 영역(메모리 영역)
    * 네이티브 메소드 스택
    * 메소드 영역 : 
    * 힙
    * 스택
    * PC레지스터

@@ GC 알고리즘 작동순서
- Stop-the-world는 GC 실행을 위해 JVM이 애플리케이션 실행을 멈주는 것이다
  >> GC를 실행하는 쓰레드를 제외한 모든 스레드들이 작업을 멈춘다. GC 작업이 완료한 이후에야 중단했던 작업을 다시 시작한다. 대개의 경우 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것을 말한다.
- GC 알고리즘은 힙 영역에서 이루어진다
- 힙은 young, old, perm이 있는데 jdk8부턴 perm는 사라진다
- old의 virtual 부분도 가상영역이므로 고려하지 말자
- Young(eden, survivor1, survivor2), Old(메모리 영역)
- 메모리에 객체가 생기면 eden 영역에 지정된다. >> eden 영역이 꽉차면 
  GC 알고리즘을 실행한다. >> 살아남은 객체를 survivor1, 2중 빈곳에 넣는다
- survivor1 영역이 꽉찬다면 GC가 실행되면서 eden영역에서 살아남은 객체와 
  survicor1에 있는 객체를 survivor2영역으로 옮긴다.

** GC의 종류
    - 마이너 GC : Young영역에서 발생하는 GC
    - 메이저 GC : old Perm영역에서 발생하는 GC

@@ java는 Call-by-value
- value의 메커니즘을 변수의 타입에 따라 다르게 적용되게끔 해버렸다.
- 자바는 기본자료형에 해당하는 변수를 아규먼트로 넘길 때는 값을 넘기고, 
  참조 자료형을 아규먼트로 넘길때는 레퍼런스를 넘기는 것처럼 보이게 되어있다.
  * 매개변수로 넘어오는 변수가 가르키는 인스턴스 메모리 주소를 넘겨주므로 call-by-value다
  * 실제 자바도 참조 타입을 인자로 전달할때 참조를 넘기지만 바로그 참조가 아니라 참조의 사본값을 넘기므로 call-by-value다

@@ 리플렉션이란 무엇인가?
- Java Reflection >> Java API
   클래스에 대한 정보를 얻는 방법 즉, 해당 클래스의 필드, 생성자, 메소드 정보뿐만 아니라, 각 메소드의 리턴타입, 매개변수 등 메소드 시그니처 정보도 얻어낼 수 있고, 하다못해, 클래스의 계층구조(부모/자식관계까지도)도 얻어낼 수 있게 해줌.
- 자바 클래스 파일은 바이트 코드로 컴파일되어 Static 영역에 위치하게 됩니다.
  때문에 클래스 이름만 알고 있다면, 언제든 이 영역을 뒤져서 클래스에 대한 정보를 가져올 수 있다.

@@ Stream API란?

@@ Lambda란?
- 람다 표현식 : 메소드를 하나의 식으로 표현한 것.

@@ 함수형 인터페이스란?

@@ foreach를 사용할 수 있는 자료구조는 어떤 인터페이스를 상속받고 있나요?
- iterable 인터페이스를 구현한 객체만이 for-each loop를 사용할 수 있는데
- iterable 을 구현하지 않은 객체가 for-each loop를 사용하면 
  자바 컴파일러가 for-each loop를 for loop로 적절하게 번역을 해준다는 사실.

@@ iterator와 iterable 차이는?

@@ synchronized 키워드에 설명하시오

@@ final 키워드에 대해서 설명 해주세요
- 필드선언시, 생성자에서만 초기화 가능
- final 필드는 객체마다 저장되고 && 생성자에서 수정가능하므로 상수라고 하지 않는다.

@@ 상수(static final)
- 객체마다 저장되지 않고, 클래스에만 포함된다.
- 한번 초기값이 저장되면 변경할 수 없다. (선언과 동시에 초기화, static 블록)

@@ Wrapper Class란? p.527
- 이렇게 8개의 기본 타입에 해당하는 데이터를 객체로 포장해 주는 클래스를 
  래퍼 클래스(Wrapper class)라고 합니다. 래퍼 클래스는 각각의 타입에 해당하는 데이터를 인수로 전달받아, 해당 값을 가지는 객체로 만들어 줍니다.

- 프로그램에 따라 기본 타입의 데이터를 객체로 취급해야 하는 경우가 있습니다.
  예를 들어, 메소드의 인수로 객체 타입만이 요구되면, 기본 타입의 데이터를 그대로 사용할 수는 없습니다.이때에는 기본 타입의 데이터를 먼저 객체로 변환한 후 작업을 수행해야 합니다. 

@@ 클래스 : 객체를 만들어 내기위한 설계도

@@ 객체 : 
- 클래스의 인스턴스로써 소프트웨어 세계에 구현할 대상을 말함
- 객체는 모든 인스턴스를 대표하는 포괄적인 의미가 있다.
- oop의 관점에서 클래스의 타입으로 선언되었을 때 ‘객체’라고 부른다

@@ 인스턴스
- 객체를 소프트웨어에 실체화 한것
- 객체에 포함된다.
- 객체기 메모리에 할당되어 실제 사용될때 인스턴스라한다.

@@ 클래스(Class) VS 객체(Object)
클래스는 ‘설계도’, 
객체는 ‘클래스로 구현한 모든 대상’을 의미한다.

@@ 객체(Object) VS 인스턴스(Instance)
- 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
- 객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.

@@ Java Generic이란?
- 제네릭 : 데이터의 타입을 일반화한다는 것을 의미한다. 
  클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일시에 미리 지정하는 방법
- 제네릭 타입 : 타입을 파라미터로 가지는 클래스와 인터페이스

@@ 순수 추상 클래스와 인터페이스의 차이

@@ 인터페이스는 언제 사용되는가?

@@ equal(메소드)과 "=="(연산자)의 차이
- 대상의 내용을 비교하고, 대상의 주소값을 비교한다.

@@ hashCode란 무엇인가?

@@ 문자열을 리터럴로 할당하는 것과 객체로 할당하는 방식의 차이가 무엇인가?
- 리터럴로 생성하면 상수풀에 할당된다
- 객체는 힘영역에 할당

@@ JCF에대해서 설명해보시오

@@ Array와 ArrayList의 차이점은 무엇인가?
- 배열은 크기가 고정되어있지만 arrayList는 사이즈가 동적인 배열이다.
- 배열은 primitive type(int, byte, char 등)과 object 모두를 담을 수 있지만,
  arrayList는 object element만 담을 수 있다.
- 배열은 제네릭을 사용할 수 없지만, arrayList는 타입 안정성을 보장해주는
  제네릭을 사용할 수 있다.
- 길이에 대해 배열은 length 변수를 쓰고, arrayList는 size() 메서드를 써야한다.
- 배열은 element들을 할당하기 위해 assignment(할당) 연산자를 써야하고,
  arrayList는 add() 메서드를 통해 element를 삽입한다.

@@ char 타입과 string 타입으로 나뉘어져 있는 이유는 무엇인가?
==================================스프링==================================
@@ IOC
- 객체의 생성에서부터 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀐 것을 의미, 또는 제어 권한을 자신이 아닌 다른 대상(Ioc Container)에게 위임하는 것이다.

@@ DI
- Spring 프레임워크에서 지원하는 IoC의 형태
- 컨테이너가 실행 흐름의 주체가 되어 애플리케이션 코드에 의존관계를 주입해주는 것.

@@ AOP(관점 지향 프로그래밍)
- 소스 코드에서 여러 번 반복해서 쓰는 코드(= 흩어진 관심사, Concern)를 Aspect로 모듈화하여 핵심 로직에서 분리 및 재사용
- 개발자가 핵심 로직에 집중할 수 있게 하기 위함
- 주로 부가 기능을 모듈화
- 자주 사용되는 부가적인 기능을 모듈화 한것

@@ dao, service, dto, vo
+ DAO(Data Access Object)
- DB의 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 객체를 말한다.
- DB에 접근을 하기위한 로직과 비즈니스 로직을 분리하기 위해서 사용 한다.

+ DTO(Data Transfer Object)
- 계층간 데이터 교환을 위한 자바빈즈를 말한다.
- 여기서 말하는 계층은 Controller, View, Business Layer, 
  Persistent Layer 이다.
- 일반적인 DTO는 로직을 갖고 있지 않는 순수한 데이터 객체이며, 
  속성과 그 속성에 접근하기 위한 getter, setter 메소드만 가진 클래스이다.
- VO(Value Object) 라고도 불린다.
  DTO와 동일한 개념이지만 read only 속성을 가진다.

@@ Bean
- Spring에서 POJO(plain, old java object)를 ‘Beans’라고 부른다.
- 애플리케이션의 핵심을 이루는 객체이며, Spring IoC컨테이너에 의해 인스턴스화, 관리, 생성된다.

@@ POJO
- 프레임워크 인터페이스나 클래스를 구현하거나 확장하지 않는 단순한 클래스.

=========================================================================
@@ 프로세스와 스레드의 차이는 무엇인가요?
- 프로세스 : 실행중인 프로그램, 프로그램 실행의 인스턴스
- 스레드 : 프로세스의 작업 실행단위 >> 프로세스가 할당받은 자원을 이용하는 
  실행의 단위
- 프로세스에 할당되는 메모리 안에는 코드, 데이터, 힙, 스택 영역을 포함한다.
- 스레드는 프로세스 내에서 스택만 따로 할당받고, 코드 데이터 힙 영역은 공유한다.
- 스레드는 한 프로세스 내에서 동작하는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드 끼리 공유하면서 실행된다.
=========================================================================
@@ 라이브러리
- 프로그램 제작 시 필요한 기능
- 재사용이 필요한 기능으로 반복적인 코드 작성을 없애기 위해 언제든지 필요한 곳에서 호출하여 사용할 수 있도록 Class나 Function으로 만들어진 것입니다.

@@ 프레임워크
- 어떤 사건이 일어나는 토대를 제공하는 것
- 원하는 기능 구현에만 집중하여 빠르게 개발 할 수 있도록 기본적으로 필요한 기능을 갖추고 있는 것으로 위에서 설명한 라이브러리가 포함되어 있습니다.
- 프레임워크만으로는 실행되지 않으며 기능 추가를 해야 되고 프레임워크에 의존하여 개발해야 되며 프레임워크가 정의한 규칙을 준수해야 합니다.

@@ 아키텍처
- 프로그램 주요 구조 설계
- 기획한 내용을 프로그램화했을 경우 필요한 주요 특징을 기술적으로 설계하고 명시하는 것입니다.
- 결과물에 필요한 모든 구성 요소를 명시하지만, 구체적인 구현 방법은 포함되어 있지 않습니다. 가령, 아래에서 설명할 플랫폼은 주요 특징이지만 프레임워크와 라이브러리는 주요 특징이 아니므로 명시되지 않을 가능성이 큽니다.
- 자동차 설계로 예를 들면 자동차 헤드라이트가 본넷 밑에 사각형 모양으로 존재한다고 설계하고 헤드라이트 고정 방식이 접착제인지, 볼트인지는 명시되지 않는다고 볼 수 있습니다. 하지만 상황에 따라 포함될 수도 있습니다.

@@ 플랫폼
- 프로그램이 실행되는 환경
- 프로그램이 실행되는 환경이며 플랫폼은 플랫폼위에 다른 플랫폼이 존재할 수 있습니다. 가령, Windows에서 Java로 개발하고 있으며 앱스토어에서 어플을 내려받는 과정에서 이미 3개의 플랫폼을 사용하고 있는 것입니다.
-Windows, Linux, macOS등 O/S는 모두 플랫폼입니다.
-어플을 다운받는 앱스토어, 구글플레이, 원스토어도 플랫폼입니다.
-Java 프로그램은 OS제약이 없지만 실행하기 위해서는 해당 OS에 자바 가상 머신(Java Virtual Machine, JVM)위에서 실행되므로 Java 플랫폼이 필요합니다.






ERP SAP

특징과 차이점

라이브러리
API

Iaas
pass
saas


함수적 프로그래밍이란?


사람을 모으는 능력, 정리, 문제해결력

프로젝트를 하면서 배운것
집단지성, 
역할배분 :: 구현 범위가 너무 넓다는 피드백을 받았다 그리고 그사실을 누구보다도 잘알았다 하지만 프론트엔드 팀원을 잘 선별하여서 오히려 관리자페이지를 만드는 초과성과를 달성 했습니다.

==========================================================================
자기소개서 분석
1. 높은 목표 설정
자발적으로 최고 수준의 목표를 세우고 끈질기게 성취한 경험에 대해 서술해 주십시오.
트라우마를 극복하기 위해 간호학과에 가봤습니다.
왜갔니?
가서 뭘배웠니?
이것을 어떻게 이용해서 우리회사에 기여할래?

2. 기존의 틀을 깨는 과감한 실행
새로운 것을 접목하거나 남다른 아이디어를 통해 문제를 개선했던 경험에 대해 서술해 주십시오. 

카페알바 
왜했니? 매출이 안나와서
무얼 했니? 고객을 분석하고


종이컵에 안담은 이유는 한번 담아봤는데 믹스커피를 사마실껄 이라는 생각이 들었다 그래서 2천원인데 영수증제시하면 10퍼 깎아서 1800원이었다.

상세내용
1. 국비지원 웹개발 과정 교육 수료
왜배웠니?
가서 뭘배웠니?
배운걸 어떻게 우리회사에 기여할래?

프론트엔드 html기본 Javascript기본 알아보자
자바
SQL

2. 배관 측정 기업에 전화를 했고, 배관을 만드는 기업에 전화를 했다.

3. dbguide.net에서 실시하는 DA 설계 대전

4. 딥러닝을 이용한 남녀 이미지 구분 신경망 프로젝트

5. 알고리즘 역량을 기르기 위해 학원에 다녔습니다.

자료구조
정렬


========================================================================
면접자세
면접일기
장점
빠르고 꼼꼼하고 준비성이 좋다.

단점
걱정이 많다. 겁이 많다.

정해진시간내에 정해진 일을 하는게 얼마나 중요한지 배웠다.
면접 가면 

내가 회사에 어떤 기여를 할까?

내 별명 >> 분위기전환

선택형 질문은 양쪽을 다언 급해야한다.
목소리톤

준비한걸 미리 말하려 하지말라
========================================================================
1분 자기소개서

나는 어떤캐릭터인가?
준비성, 청소, 단정, 깔끔함, 책, 노력, 끈기부족, 합처질때 강해진다, 하기 싫은 일을 눈꼭 감고 그냥했다
첫인상이 좋다, 공부가 취미다, 운동을 꾸준히한다, 한게임을 정말 오랬동안 해왔다.


끝날 때까지 끝난게 아니다.


101퍼센트의 만족감.
101퍼센트의 만족감이란? >> 

공백기

낮은 학점
=========================================================================
10월 11일 취업코치 김정우

면접합격의 필수요소 3가지 

목소리
표정
답변

물어본 부분만 대답하자. => 상대방이 듣고 싶은 이야기를 해줘야지 원만한 커뮤티케이션이 이루어진다.

백개이상의 질문을 만들고 답해보자.
========================================================================
똑똑 => 문닫고 인사하고(목례) && 문고리잡고 인사하지 말자. && 웃으면서 들어오자
=> 주먹은 쥔상태로 다리옆에 => 안녕하십니까?
=> 남자의 지나친 미소는 가벼워 보인다?

안녕하십니까? => 허리를 숙이자 => 눈을 보면서 말을 하자
자기소개는 40-50초 => 직무역량에 관련된 내용을 말하자

준비해온 과정에서 남들과 차별화되는 부분을 말하자.

"앞에서도 말씀드렸다시피" => 면접관에게 절대로 말하자.

자신의 강점을 6가지 정도 알면 좋다 && 자신말을 표현 할 수 있는 캐릭터를 만들자.

의자 등박이에 기대지말자 ( 배와 허리에 힘을 주어야한다.)
=======================================================================
프로젝트 경험에 대해서 말해 달라 => 한두가지 정도 프로젝트 경험에 대해서 정리가 되어있어야한다.
1) 역할 : 리더 - 팀원
2)가장 큰 어려움이 무엇이었니?
3)문제가 있었을때 창의적으로 
4)갈등을 겪었던 경험 => 어떻게 해소 했는지도 말해야한다.
  1. 타인이 겪고있는 "상황"과 "감정" 이해하자 => 배려하자 
  2. 적극적인 대화와 피드백을 통해서 공동의 목표를 달성해나가자.
=========================================================================
이직 => 눈피하지말고 당당하게 말하자 => 회사와 함께 성장하고 싶다. 
1분 자기소개 => 자기 소개서의 요약
========================================================================
나이가 많아서 불편한것은 내가 아니라 선배이다. => 상대방의 입장에서 말을 하자.

주먹에 본드를 붙여서 무릎에 올리자.
=========================================================================
내가 가서 어떠한 기술을 배울수 있느냐 =
회사의 대표가 어떤사람인지 알아보자 => 돈보다는 기술을 배워보자.

========================================================================

========================================================================

========================================================================








