*********** 정  의
- 하나의 객체만을 생성해 이후에 호출된 곳에서 생성된 객체를 반환하여 프로그램 전반에서 하나의 인스턴스만을 사용하게 하는 패턴입니다

*********** 특  징
- 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다
- 기본 생성자를 private 를 사용하여 생성을 불가능하게 하고, getInstance를 통해서만 생성이 가능하다
- 인스턴스를 제공하는 메서드와 인스턴스 변수 모두 Static으로 선언된 정적 변수 및 메서드입니다.

*********** 장    점
- 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있음
- 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.



*********** 단    점

1) 여러 쓰레드가 공유되고 있는 상황에서 아래의 블럭에서 조건문이 동시에 두번 돌 수 있기 때문에 하나의 인스턴스가 아닌 여러개의 인스턴스가 발생 할 위험이 있다

		public static Printer getInstance() {
    		if(printer == null) {
    			printer = new Printer();
    		}
    		return printer;
    	}

   ++ 해결책
   1. 정적 변수에 인스턴스를 만들어 바로 초기화 하는 방법
   public class Printer {
    	private static Printer printer = new Printer();
    	private static int count = 0;
    
    	private Printer(){}
    
    	public static Printer getInstance() {
    		return printer;
    	}
    
    	public synchronized static void print(String input) {
    		count++;
    		System.out.println(input + "count : "+ count);
    	}
    }

2) 인스턴스가 상태를 유지해야하는 상황에서 싱글톤은 더 고려해야할 점이 많습니다. 아래의 예제에서 count값은 각기 다른 쓰레드에서 공유하고 있고 서로 다른 프로세스에서 처리하고 있기 때문에 값이 일관되지 않을 수 있습니다.

	public class Printer {
    	private static Printer printer = null;
    	private int count = 0;
    
    	private Printer(){}
    
    	public static Printer getInstance() {
    		if(printer == null) {
    			printer = new Printer();
    		}
    		return printer;
    	}
    
    	public void print(String input) {
    		count++;
    		System.out.println(input + "count : "+ count);
    	}
    }


   ++ 해결책
   2. 인스턴스를 만드는 메서드에 동기화하는 방법
    public interface Printer {
    	public void print(String input);
    }
    
    -----------------------
    
    public class RealPrinter implements Printer {
    	private static Printer printer = null;
    
    	private RealPrinter() {
    	}
    	
    	// synchronized 키워드를 사용해서 thread-safe하게 만들었다.
		// 하지만 synchronized 특성상 비교적 큰 성능저하가 발생하므로 권장하지 않는 방법이다
    	public synchronized static Printer getInstance() {
    		if (printer == null)
    			printer = new RealPrinter();
    		return printer;
    	}
    
    	@Override
    	public void print(String input) {
    		System.out.println(input);
    	}
    }
    
    ----------------------
    
    public class UsePrinter {
    	public void doSomething(Printer printer) {
    		printer.print("fakeGet");
    	}
    }

https://blog.seotory.com/post/2016/03/java-singleton-pattern








