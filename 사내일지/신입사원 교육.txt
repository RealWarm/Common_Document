#########################################################################
운영 배포에 스프링 프로필이 도움된다

++++ 스프링 프로파일 ++++

윈도우 pc에서 파일 업로드를 개발하면 >> db pool 3개
운영은 리눅스 >> 파일 업로드 경로가 바뀜 

설정 소스를 바구지않고 배포해보자 

jvm option에 spring.porfile=dev(product)

설정정보를 바꾸지 않고 배포 가능하다 

스프링 빈 >> profile=dev면 아래껏, product면 이걸로 해라

aa의 배포는 적어도 이런걸 알고 배포해야한다.

질문이 추상적이어도 좋다 >> 

도현

1. 자바코드 안에 다가 로그찍어서

2. spring xml에 프로파일 설정(로그찍기를 한다?) >> 엔터프라이즈에서는 이렇게
#########################################################################
네트워크의 기초

1. 네트워크의 구조 >> 물 데 네
2. 네트워크의 기본규칙
3. 네트워크의 구조 이해하기

허브 : 브로드캐스트함 
스위치 허브 : 보내는 쪽과 받는 쪽의 맥 주소를 이용하여 
더미허브? 

랜카드 = 이더넷 카드

랜 : 물리적장치
이더넷 : 논리적 행위

맥 주소 테이블 여부 >> 스위칭, 허브의 구분

내부통신용 사설 아이피
외부 공인 아이피

8비트 = 옥탯
19 168 >> 클래스


리눅스
데비안(우분투), 라즈베리
redhat

ls -ltr
ls -l

배쉬 셀 >> 탭
쉘이란 뭘까? 커널은 뭘까?

pwd 현재의 경로 출력
rm -rf >> 디렉토리 삭제
cp -rp >> 기존 권한까지 복사가 된다.

yum
#########################################################################
코더가 아니라 프로그래머가 되기를 바란다
아키텍처와 비즈니스를 접목할 줄 아는 사람이 되길 바란다

1998 enterprise java bean (=EJB) 1.0 발표(Servlet과 Jsp가 등장함)
>> 대규모의 트랜잭션을 처리한다 = enterprise

분산객체 시스템 구축환경 >> 한 트랜잭션이 여러 서버에서 처리가 된다.

서버로직

EJB로 프로젝트를 만드는데 문제가 생김
WAS가 존재 하지 않음
자바 메모리 관리 + 데이터베이스 연동 + 세션과 같은 중요한 작업이 너무 많았다.
>> WAS의 필요성을 깨닭음

컨테이너가 할 일
메모리를 관리해줄 
레진 컨테이너 >> 톰캣 >> JNDI 아키텍처를 도입한 WAS를 

최초로 생긴 WAS : 웹로직

2002년 스프링 1.0발표 + JDK1.4 버전이 등장함
JDK 1.4에서는 리플렉션+인스트루먼트 >> 이 것들을 이용한 스프링이 등장함

EJB가 도태된 이유 >> mvc라는 개념이 들어갈 수 없었다. & 유지보수하면 관련된것들도 건들여야했다. >> 유지보수가 너무 힘들었다.

WAS가 9001포트에 기동됨 >> 하나의 인스턴스인 것이다.
이러한 와스 인스턴스 안에 WAR를 배포하면 그건 컨테이너이다.

컨테이너 가상화 

하나의 와스에 여러게의 인스턴스를 올리면 AUTOSCALE OUT면 뻗을 수도 있다.
>>그래서 하나의 was에 하나의 컨테이너만 올린다.

***** 자바 SE, EE의 종류와 기능을 조사 해보자

JRE는 JAVAC(컴파일러가 없다)


서블릿 TCP/IP 기반이다.

**** dispatcher-servlet >> 분기해서 찾아준다

jsp가 서버에 올라가면 서블릿으로 바뀌어서 올라간다.

jsp가 컴파일되서 서블릿으로 바뀐게 >> 
예를 들어 인코딩 언어를 바꾸면 크기가 바뀌지 않아서 컴파일러가 다시 컴파일 하지않는다 그래서 깨진 파일이 계속나온다. >> 오류생기면 was안의 클래스파일을 없애면 된다.

jsp가 서블릿이 되는것 = 제너레이트(자동으로 코드로 바뀌는것?)

jsp를 서블릿클래스로 바꾸어주는것 >> 서블릿 컨테이너

서블릿 생명 주기

was의 메모리는


못들었어 ㅠㅠ 

old와 new가 있다.

성능테스트 >> 예열 부하 >> 메모리 올라오게 한다.

객체로써의 메모리
쓰레드로써의 메모리 

aop는 리플렉션과 인스트르먼트를 이용한다.

apm? 제니퍼?? 작동에
인스트르먼트를 이용하면 객체(클래스)에 접근 할 수 있다
preinsert, postinsert

필터링이 제일 먼저 >> web.xml에 있어서 
필터 >> APM >> 인터셉터 ( APM과 인터셉터의 순서는 바뀔 수도 있다.)

헤더에 메소드가 겟, 포스트
겟 >> 바이너리코드 업로드 안됨 >> 파일 업로드는 포스트만
겟은 8092바이트를 초과하는 데이터를 전송 못한다.

웹서버(정적) >> 
동적인게 오면 php, asp 외부에서 처리하고 웹서버에게 돌려준다

was(동적) >> .do, .jsp 만 있다?


캐쉬를 설정해놓으면 헤더정보에 expire가 추가 된다 >> 쿠키와는 다른 개념이다.

몇명의 사용자를 커버할수있는 서버인지를 파악해야한다


전자정부 fw
db스키마
메뉴 50개
사용자 50명
게시판 공지사항 50개
메인화면이 조회되는 구조

+

jmeter로 1000명의 부하를 줘보자 >> 과연 어떻게 나올까?

100명을 수용하는 프로젝트를 1000명을 수용하게 하려면 어떻게 해야할까?

우리의 과제는 저런거다.

계층구조의 메뉴구조는 데이터 베이스에 부담이 많이 된다.


** 화면 엑박떠도된다. 화면 하나도 안이뻐도 된다.


매일매일 점심시간 끝나고 티타임 갖자 >> 수요일 빼고

발표, 질문한 사람들을 기억한다
다른 언어들을 공부하면 좋은 아이디어를 얻는다.
#########################################################################
OPEN API

[1] RestFul API 만들기
1. CXF 라이브러리
2. 스프링 RESTFUL >> 아주쉽다 >> WADL 웹서비스 명세 정보 추출이안나옴

[2] SOAP >> 명세정보가 WSDL이 나온다 >> 더어렵다 >> 시간되면 해봐라
1. CXF 라이브러리

[명세정보란?]
공 통 : URI + REQUEST + RESPONSE
REST는 서비스 오퍼레이션이 명확히 구분이 잘안됨
SOAP은 서비스 오퍼레이션이 명확히 구분이 된다

CXF 라이브러리를 이용해서 웹서비스를 구현하는데
XML, JSON 둘다 되야한다 >> 사용자의 요청 타입 파라미터에 따라서 되게끔!

[클라우드의 사상]
로드밸런서가 오토 스케일 아웃한다(WAS) 
왜 RESTFUL이 필요하지? >> 

가로로 쪼개는 법 FRONT BACK
세로로 쪼개는 법

2002 와스 등장
2004 JDK 1.5업그레이드 >> 웹서비스(SOAP) 개념등장  
>> 데이터 연계아키텍처(EAI) 등장
{연계 방식}
1. API TO API
2. FILE TO FILE
3. DB TO DB

2008 레거시를 웹서비스로 만들자 >> 다른 시스템의 의존성을 낮출수 있지않을까? 
>> SOA(서비스 지향 아키텍처)등장 >> 클라우드라는 개념 등장함

가상화 + 가상화에 대한 "관리 API" = 클라우드 >> IAAS의 시작
컨테이너 가상화 >> PAAS
SAAS 는?

클라우드 아키텍처는 RESTFUL API가 반드시 들어간다.

클라우드 MSA API에 첫 발을 띄운거다.

웹서비스 컨트롤러 코드 만드는법
1. string
2. ResponseEntity
3. void
각각 다해보자 다 장단점이 있다
** 보안에 취약하다 >> 인증체계가 필요하다 >> Session으로 인증 x >> 인증키, 아이피 기반 인증방식이 있다
cxf >> prehandler posthandler 인터셉터를 사용하면 쉽게 된다.

유지보수가 편해진다!!

++ SSO도 만들 수 있게된다.

CXF >> 메이븐 >> 버전 몇으로 할지 조사해보자 >> 최신버전이 좋은건 아니다 >> 지금하고있는 JDK, SPRING의 버전과 궁합이 잘맞는 것을 선택해보자

context-webservice.XML(?)
#########################################################################
1) DispatcherServlet : 클라이언트 요청을 핸들러 매핑에게 던져준다.
(스프링 패키지 안에 있다 >> 서블릿으로 등록만 해주면 된다.)
2) HandlerMapping : 여러개의 컨트롤러 중에 가장 적합한 컨트롤러를 선택해준다.
3) HandlerAdapter : 선택된 컨트롤러 안의 여러 함수중 사용자가 요청한 작업과 가장 적합한 함수를 선택해준다. 
4) ViewResolver : 컨트롤러에게서 받은 모델과 뷰를 기준으로 가장 적합한 jsp 문서를 찾아준다.
(2번 3번 4번 >> 스프링 컨테이너가 알아서 생성해주고 알아서 작동한다. 개발자 관여(X) ++++ 컨트롤러와 뷰만 개발자가 담당한다)
5) 클라이언트에게 화면과 데이터를 응답으로 전달해준다.


web.xml이 뭔지 검색해봐라

web.xml >> DispatcherServlet을 등록한다.

servlet-context.xml >> 스프링 설정파일 >> 스프링 컨테이너를 만들어 준다.

>> HandlerMapping, HandlerAdapter, ViewResolver가 컨테이너에 생성된다.

** DispatcherServlet만 등록하고 servlet-context.xml를 등록하지 않았다면

appServlet-context.xml을 이용하여 스프링 컨테이너(위와 같은)를 만든다


+ Controller객체 - @Controller
servlet-context.xml 안에 <annotation-driven />라는 태그를 넣어준다 
>> 스프링 컨테이너를 사용하기 위해 도와주는 여러 빈객체들을 만들어 준다?
>> @Controller 어노테이션을 사용할 수 있게 해준다

+ Controller객체 - @RequestMapping
#########################################################################


































